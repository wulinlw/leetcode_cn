# #!/usr/bin/python
# #coding:utf-8
# 
# 面试题17.01.不用加号的加法
# 
# https://leetcode-cn.com/problems/add-without-plus-lcci/
# 
# 设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。
# 示例:
# 
# 输入: a = 1, b = 1
# 输出: 2
# 
# &nbsp;
# 
# 提示：
# 
# 
# 	a,&nbsp;b&nbsp;均可能是负数或 0
# 	结果不会溢出 32 位整数
# 
# 
# 
# Easy 52.4%
# Testcase Example: 1
# 2
# 
# 提示:
# 手动（慢慢地）完成二进制加法，尝试真正理解发生了什么。
# 你可以把二进制加法看成是对数字的每一位进行迭代、两位进行加和，并在必要时进位。你也可以对操作进行分组。如果首先对每位相加（不进位）会怎样？之后，你可以再处理进位。
# 只关注上面的一个步骤。如果你“忘记”进位，那么加法操作会是什么样子?
# 仅相加步骤就可以做如下转化：1 + 1 -> 0，1 + 0 -> 1，0 + 1 -> 1，0 + 0 -> 0。没有+号要怎么做?
# 可以使用XOR执行加法步骤。
# 现在关注进位。在什么情况下两个值会进位？如何使用进位？
# 进位在1 + 1时发生。如何将进位应用到数值中？
# 可以用AND运算来计算进位。如何使用它？
# 你可能需要不止一次地执行加法/进位操作。将进位加到和中可能会产生新的进位值
# 
# 

class Solution:
    def add(self, a: int, b: int) -> int:
        a &= 0xFFFFFFFF                         #二进制长度限制，取有效部分，题目要求的32位整数
        b &= 0xFFFFFFFF
        while b:                                #有进位就循环处理
            carry = a & b       
            a ^= b                              #异或，取不进位部分的和，不管进位
            b = ((carry) << 1) & 0xFFFFFFFF     #取进位
        return a if a < 0x80000000 else ~(a^0xFFFFFFFF)

a=-1
b=2
a=1
b=-2
o = Solution()
print(o.add(a, b))