# #!/usr/bin/python
# #coding:utf-8
# 
# 面试题17.10.主要元素
# 
# https://leetcode-cn.com/problems/find-majority-element-lcci/
# 
# 如果数组中多一半的数都是同一个，则称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。
# 示例 1：
# 
# 输入：[1,2,5,9,5,9,5,5,5]
# 输出：5
# 
# &nbsp;
# 
# 示例 2：
# 
# 输入：[3,2]
# 输出：-1
# 
# &nbsp;
# 
# 示例 3：
# 
# 输入：[2,2,1,1,1,2,2]
# 输出：2
# 
# &nbsp;
# 
# 说明：
# 你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？
# 
# 
# Easy 63.7%
# Testcase Example: [3,2,3]
# 
# 提示:
# 从蛮力解法开始。你能检查一下每个值是否为主要元素吗?
# 考虑蛮力解法。我们选择一个元素，然后通过计算匹配和非匹配元素的数量来验证它是否是主要元素。假设对于第一个元素，前几次检查显示 7 个不匹配的元素和 3 个匹配的元素。有必要继续检查这个元素吗?
# 主要元素一开始看起来并不一定像主要元素。例如，有可能主要元素出现在数组的第一个元素中，然后在接下来的 8 个元素中都不再出现。但是，在这些情况下，主要元素将在数组的后面出现(实际上，在数组的后面会出现很多次)。当某个元素看起来“不太像”主要元素时，继续检查它并不一定很重要。
# 还要注意，主要元素对于某些子数组也必须是主要元素，而且子数组不能拥有多个主要元素。
# 试试这个:给定一个元素，开始检查它是否是一个子数组的开始，同时对于这个子数组，该元素是它的主要元素。一旦它变得“不太可能”(出现的次数少于一半)，就开始检查下一个元素(子数组之后的元素)。
# 
# 
from typing import List
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        dicts = {}
        for i in nums:
            dicts[i] = dicts.get(i,0)+1     #统计出现次数
        mid = len(nums)>>1
        for i,v in dicts.items():
            if v > mid:                     #长度大于一半，返回
                return i
        return -1

nums = [2,2,1,1,1,2,2]
o = Solution()
print(o.majorityElement(nums))